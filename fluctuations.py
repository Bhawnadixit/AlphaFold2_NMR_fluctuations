import os 
import pandas as pd
import numpy as np


RES_MASS = {
    'ALA': 71.079018,
    'ARG': 157.196106,
    'ASN': 114.104059,
    'ASP': 114.080689,
    'CYS': 103.143407,
    'GLU': 128.107678,
    'GLN': 128.131048,
    'GLY': 57.052030,
    'HIS': 137.141527,  # HSE/HSP/HSD ignored
    'ILE': 113.159985,
    'LEU': 113.159985,
    'LYS': 129.182660,
    'MET': 131.197384,
    'PHE': 147.177144,
    'PRO': 97.117044,
    'SER': 87.078323,
    'THR': 101.105312,
    'TRP': 186.213917,
    'TYR': 163.176449,
    'VAL': 99.132996,
}

def mass_protein(Rs, full=False, weighted=True):
    '''
    Retrieve the mass for each residue in 'Rs'
    Rs: list of 3-letter residue names 
    full: set True if residue name is in the format A.GLY123 (used modefile)
    weighted: set True if mass needs to be square-rooted

    TODO: use as only internal function  __mass_protein
    '''
    if full:
        Rs = [r[2:5] for r in Rs]    
        # skip letter 0,1, (e.g. A.) and take letters 2,3,4 (e.g. GLY)

    # look up the masses in the dictionary
    Rs_mass = [RES_MASS[r.upper()] for r in Rs]

    if weighted:
        Rs_mass = [r**0.5 for r in Rs_mass]
        # return sqrt(mass) instead of mass
    return Rs_mass
        

aa_dict = {
    'A': ['Ala', 'Alanine'],
    'R': ['Arg', 'Arginine'],
    'N': ['Asn', 'Asparagine'],
    'D': ['Asp', 'Aspartic acid'],
    'C': ['Cys', 'Cysteine'],
    'Q': ['Gln', 'Glutamine'],
    'E': ['Glu', 'Glutamic acid'],
    'G': ['Gly', 'Glycine'],
    'H': ['His', 'Histidine'],
    'I': ['Ile', 'Isoleucine'],
    'L': ['Leu', 'Leucine'],
    'K': ['Lys', 'Lysine'],
    'M': ['Met', 'Methionine'],
    'F': ['Phe', 'Phenylalanine'],
    'P': ['Pro', 'Proline'],
    'S': ['Ser', 'Serine'],
    'T': ['Thr', 'Threonine'],
    'W': ['Trp', 'Tryptophan'],
    'Y': ['Tyr', 'Tyrosine'],
    'V': ['Val', 'Valine']
}


# converts three-letter to one letter from aa_dict
swapped_aa_dict = {v[0].upper(): k for k, v in aa_dict.items()}


# all parameters below are taken from webnma github
MODE_NM = 200          # mode num defined by webnma
mode_nums = range(7, MODE_NM+7)

# units
T = 300
TMP = 300  # temperature in Kelvin
Units_k_B = 1.3806513e-23 * 6.0221367e23 / 1.0e3  # in units kJ/mol/K

#kB = 1.3806513e-23
#kB = 1.380649e-23  # [J/k] Wikipedia, "exact" since 2018, says NIST
#kB = 8.314462618e-3  # [kJ/mol/K] Wikipedia
# this is kind of the same number as Units_k_B

# This is 300 K instead of 310 K, but that is not really a problem

mode_nums=range(7, MODE_NM+7)
print(mode_nums)


def read_modes_2(filename, doprint=True):
    # file modes.txt
    #----------------
    # This file gives modevectors.txt with eigenvalues, amino acid sequence, and eigenvectors
    # File generated by WebNMA
    
    # 1) read eigenvalues, on 5th line
    # 2) read sequence, on 6th line
    with open(filename, 'r') as f:
        lines = f.readlines()
        line_evals = lines[4]
        line_sequence = lines[5]
        # split line and convert to floats
        evals = np.array([float(word) for word in line_evals.split()])
        sequence = line_sequence.split()  # just split

    nres = len(sequence)
    veclength = nres*3    # length of a normal mode vector (x,y,z for every Calpha)
    
    # 3) read vectors, starting at 7th line
    # this is a numpy array
    evecs = np.loadtxt(filename, skiprows=6,)  #delimiter=' ', 
    
    if doprint:
        print("reading...", filename)
        print("evals", len(evals))   # this is just 200+6=206 (except for very small protein)
        print(evals)
        print("sequence ", nres)
        print("veclength", veclength)
        #print(sequence)
        print("evecs", evecs.shape, "should be similar to nres x 206")
        print("evecs")
        print(evecs)
    return evals, sequence, evecs, nres

def read_params(filename, doprint=True):
    # file.txt
    #---------------
    # Here we read low-frequency modes eigenvalues from eigen.txt which is a different file
    data_file = np.loadtxt(filename,  skiprows=1)  #delimiter=' ',
    data = data_file[:,1]  # second column of file
    
    param = filename.split('/')[-1].split('.')[0]    # name of the parameter to read
    if doprint:
        print("reading...", filename)
        print(param, data.shape)
        print(data)
    return data

def read_displacement_2(filename):
    data = np.loadtxt(filename, skiprows=1, delimiter='\t')
    disp = data[:,1]
    return disp


def omega_to_lambda(w):
    """
    Switch omega(raw eigenvalues in modefiles) squared values to 
    lambda(frequencies)
    """
    return abs(w)**0.5 / (2 * np.pi)

# Transform a raw mode (used in MMTK/WEBnma2) into a Vibrational mode
def rawmode_to_vibrational(mode_arr, freq, weights):
    amplitude = np.sqrt(2 * T * Units_k_B) / (2 * np.pi * freq)
    v_mode = [coord * amplitude / weights[i//3]  for i, coord in enumerate(mode_arr)]
    return np.array(v_mode)



def rawmode_to_vibrational_2(mode_arr, freq, weights):
    """Function that normalizes the mode w.r.t. mass tensor and applies frequency prefactor
    
    mode_array -- mode vector that is normed (or not, not important, actually)
    freq -- the eigenvalue
    weights -- should be sqrt(masses)
    """
    
    # the vector is normed with respect to kinetic tensor (mass tensor), 
    # i.e.  x'^T.x' = 1  where x' = M^1/2 . x, so actually x^T.M.x = 1
    
    # undo the mass weighting: x = M^(-1/2).x'  so devide by sqrt(mass)
    mode = [coord / weights[i//3]  for i, coord in enumerate(mode_arr)]
    mode = np.array(mode)
    # this is the vector in the correct Cartesian coordinates, 
    # it is not mass-weighted and not normed
    
    # I moved this!!!
    # amplitude = A*sqrt(T)/freq    where A is universal prefactor
    return mode


def calc_disp_2(es, rs, modes, mode_num, donorm="no"):
    """Function that determines vibrational SQUARED displacements *100
    
    for every residue x**2 + y**2 + z**2 according to the mode
    
    es -- eigenvalues
    rs  -- sequence, residue names
    modes -- eigenvectors with normed vectors in the columns
    mode_num -- select a mode vector: WATCH OUT, NUMBERING STARTS with 1
    donorm -- whether displacement is normed or not (default True)
    """
    index = mode_num -1
    ca_num = len(rs)   # number of residues

    # undo mass-weighting of selected mode
    weight = mass_protein(rs, full=True)  # weight=True default, so this is sqrt(mass)
    mode_vib = rawmode_to_vibrational_2(modes[:, index], es[index], weight)

    # x**2 + y**2 + z**2 for each atom, using un-weighted mode vector
    disp = [sum(a_coord**2) for a_coord in mode_vib.reshape(ca_num,3)]
    disp = np.array(disp)
    # these are SQUARED displacements * 100
    
    if donorm=="tot-square-disp":   # get values between 0 and 100 [no unit]
        disp *= 100/np.sum(disp)   # norm by the length square of the vector, and *100

    elif donorm=="tot-disp":   # get values between 0 and 100 [no unit]
        disp *= 100/np.sum(np.sqrt(disp))   # norm by the sum of displ (not squared), and *100

    elif donorm=="eigenvalue":  # [unit angstrom**2]
        # let's weigh with kBT/omega**2
        # now you have unit nm**2
        # multiply with 100 to get Angstrom**2
        amplitude = Units_k_B*T/es[index] * 100
        disp *= amplitude
    elif donorm=="no":  # [unit 1/mass or so]
        pass
    else:
        raise Error("not known: donorm =", donorm)
    return disp


def calc_fluc_2(es, rs, modes, mode_nums=[], donorm="rmsf"):
    """Function that determines RMSF
    
    es -- eigenvalues
    rs  -- sequence, residue names
    modes -- eigenvectors with normed vectors in the columns
    mode_num -- select a mode vector: WATCH OUT, NUMBERING STARTS with 1
    donorm -- determines output (default "rmsf")
                rmsf             - RMSF          [unit angstrom]
                msf              - MSF = RMSF**2 [unit angstrom**2]

            Normed profiles:
                rmsf_N           - RMSF / natom       [unit angstrom]
                rmsf_sqrt_N      - RMSF / sqrt(natom) [unit angstrom]
                msf_N            - MSF / natom        [unit angstrom**2]
                msf_sqrt_N       - MSF / sqrt(natom)  [unit angstrom**2]

            Normed profiles: [no unit]
                rmsf4_norm       - WebNMA = RMSF**4 / sum(RMSF**4)
                rmsf_totrmsf     - RMSF / sum(RMSF)
                rmsf_sqrt_totmsf - RMSF / sqrt(sum(MSF))
                msf_totmsf       - MSF / sum(MSF)
                
                
    * Desired non-normed result: MSF
    Eq. 42 in Ghysels et al., J. Comput. Chem. 2012
    but prefactor (kBT) likely wrong
    
    * RMSF instead of MSF is also very good.
    
    * Desired normed result:
    only 200 modes, ...XXXXXXX still thinking about this
    """
    
    ca_num = len(rs)
    
    # get the masses: weight=False, so this is mass, not sqrt(mass)
    mass = mass_protein(rs, full=True, weighted=False) 
    
    # take the selected eigenvalues (es_n) and modes (modes_n)
    # watch out: the modes are in the rows now
    if len(mode_nums) > 0 and max(mode_nums) <= len(es) :
        mode_nums = [n-1 for n in mode_nums]  
        es_n = [es[n] for n in mode_nums]    
        modes_n = [modes[:,n] for n in mode_nums]
    else:
        # use all non-trivial modes 
        es_n = es[6:]
        modes_n = np.array(modes[:,6:]).transpose()
    
    if False: # as done in WebNMA
        """ This is interpretation of WebNMA code"""
        # function that computes something with coord and e
        # f = lambda coord, e: sum(coord**2)/ e**2
        # needs to be changed here! because input is eigenvalues (not sqrt(eigenvalues))
        # because I used my own read_modes_2, not read_modes from webnma
        f = lambda coord, e: sum(coord**2)/ e

        # apply function
        flucs1 = [[f(a, es_n[i]) for a in mode.reshape(ca_num,3)]
                                  for i, mode in enumerate(modes_n)]
        flucs1_tr = np.array(flucs1).transpose()

        # Note:
        # flucs1 is list
        # 1 element per mode i
        # a, es_n[i]   takes the x,y,z displacement of atom a
        #              in the mode vector corresponding to eigenvalue i
        # then it computes f( (x,y,z), eig )
        # it returns x**2 + y**2 + z**2 / eig**2
        # finally, 
        # convert to: nres x number of modes
        
        # loop over atoms: 1/mass, then sum over modes
        flucs = [sum(f)/mass[i] for i, f in enumerate(flucs1_tr)]
        flucs = np.array(flucs)
        # [no unit]

    else:  # as repeated by AG
        """This is my implementation: it gives the same as in WebNMA"""
        nmodes = len(es_n)
        disp = np.zeros((ca_num, nmodes))
        for i in range(nmodes):
            disp[:,i] = [sum(a_coord**2) for a_coord in modes_n[i,:].reshape(ca_num,3)]
        flucs = (disp.T/mass).T/es_n
        #print("flucs", flucs.shape)
        flucs = np.sum(flucs, axis=1)
        # [no unit]
    
    # amplitude
    #==========
    # amplitude never visible in output WebNMA because it flucs are normalized
    # WebNMA suggests:
    #s = Units_k_B * TMP / (2. * np.pi) **2
    # But it is simpler in this function, because I never went to "freq" and stayed
    # with the eigenvalues "omega**2" that come out of the diagonalization
    prefactor = Units_k_B * T
    flucs *= prefactor
    # now flucs has unit: nm**2
    flucs *= 100
    # now flucs has unit: angstrom**2
    
    #======================
    # flucs is now RMSF**2
    #======================
    
    # normalize the whole profile
    if donorm == "rmsf4_norm":       # this becomes RMSF**4, norm sum(RMSF**4) (THIS IS WEBNMA)
        # [no unit], values between 0 and 100
        if False:
            # as done in WebNMA
            flucs = sq_norm(flucs)
        else:
            # repeated by AG, this gives the same thing
            flucs = 100 * flucs**2 / np.sum(flucs**2)

    # do not norm
    elif donorm == "rmsf":       # this becomes RMSF
        flucs = flucs**0.5
        # [unit angstrom]
    elif donorm == "msf":        # this is just RMSF**2, unchanged
        pass
        # [unit angstrom**2]

    # use number of particles to norm (this does not change the unit)
    elif donorm == "rmsf_N":     # RMSF, norm with natom
        flucs = flucs**0.5 / ca_num
        # [unit angstrom]
    elif donorm == "rmsf_sqrt_N":     # RMSF, norm with sqrt(natom)
        flucs = flucs**0.5 / np.sqrt(ca_num)
        # [unit angstrom]

    elif donorm == "msf_N":     # MSF, norm with natom
        flucs = flucs / ca_num
        # [unit angstrom**2]
    elif donorm == "msf_sqrt_N":     # MSF, norm with sqrt(natom)
        flucs = flucs / np.sqrt(ca_num)
        # [unit angstrom**2]
    
    # norm the profile (this removes the unit)
    elif donorm == "rmsf_sqrt_msftot":     # RMSF, norm with sqrt(sum(MSF))
        flucs = flucs**0.5 / np.sqrt(np.sum(flucs))
        # [no unit]
    elif donorm == "rmsf_rmsftot":    # RMSF, norm with sum(RMSF)
        flucs = flucs**0.5 / np.sum(flucs**0.5)
        # [no unit]
    elif donorm == "msf_msftot":     # MSF, norm with sum(MSF)
        flucs = flucs / np.sum(flucs)
        # [no unit]
        
    else:
        raise Error("Value not known for donorm: ", donorm)
    return flucs
    
# I just repeated the same function here from webnma
# squared normalization of a 1D array
def sq_norm(arr):
    s = sum(arr**2)
    return 100 * arr * arr / s
# Note AG
# I think this function is the trouble with WebNMA
# It gives arr*arr, which is arr**2
# so it takes RMSF**2 as input and computes the square
# which is (RMSF**2)**2 = RMSF**4




